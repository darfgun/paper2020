boxplot(err.L2,main="L2 error")
## Simulated data - Brownian paths
n <- 1e4
d <- 500
x <- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x <- t(apply(x,1,cumsum))
## Computation speed
system.time(replicate(10, {
median.est = Gmedian(x)}))
system.time(replicate(10, {
mean.est = apply(x,2,mean)}))
source(Gmedian)
source(Gmedian.rdb)
source("Gmedian.rdb")
source("/Gmedian.rdb")
source("Gmedian.R")
source("Gmedian")
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Bachelorarbeit/Code/Cardot R Code Gmedian/Gmedian/R/GmedianTest.R')
getwd()
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Bachelorarbeit/Code/Cardot R Code Gmedian/Gmedian/R/GmedianTest.R')
setwd(C:\Users\Daniel\Google Drive\currentDocumants\Studium\Bachelor\6.Semester\Bachelorarbeit\Code\Cardot R Code Gmedian\Gmedian\R)
setwd("C:\Users\Daniel\Google Drive\currentDocumants\Studium\Bachelor\6.Semester\Bachelorarbeit\Code\Cardot R Code Gmedian\Gmedian\R")
source('C:/Users/Daniel/Desktop/Bachelorarbeit - VerknÃ¼pfung.lnk', encoding = 'UTF-8')
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Bachelorarbeit/Code/Cardot R Code Gmedian/Gmedian/R/GmedianTest.R')
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Bachelorarbeit/Code/Cardot R Code Gmedian/Gmedian/R/Gmedian', encoding = 'UTF-8')
install.packages("Gmedian")
## Simulated data - Brownian paths
n <- 1e4
d <- 500
x <- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x <- t(apply(x,1,cumsum))
## Computation speed
system.time(replicate(10, {
median.est = Gmedian(x)}))
system.time(replicate(10, {
mean.est = apply(x,2,mean)}))
##
## Accuracy with contaminated data
n <- 1e03
d <- 100
n.contaminated <- 50 ## 5% of contaminated observations
n.experiment <- 100
err.L2 <- matrix(NA,ncol=3,nrow=n.experiment)
colnames(err.L2) = c("mean (no contam.)", "mean (contam.)","Gmedian")
for (n.sim in 1:n.experiment){
x <- matrix(rnorm(n*d,sd=1/sqrt(d)), n, d)
x <- t(apply(x,1,cumsum))
err.L2[n.sim,1] <- sum((apply(x,2,mean))^2/d)
ind.contaminated <- sample(1:n,n.contaminated) ## contam. units
x[ind.contaminated,] <- 5
err.L2[n.sim,2] <- sum((apply(x,2,mean))^2/d)
err.L2[n.sim,3] <- sum(Gmedian(x)^2/d)
}
boxplot(err.L2,main="L2 error")
?rnorm
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/zettel 5 (1)/Zettel5.R')
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/zettel 5 (1)/Zettel5.R')
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/zettel 5 (1)/Zettel5.R')
# Solution to generate the data
N<-c(10,100,1000,5000)
I<-50000
n<-N[0]
n
n<-N[1]
n
data <- matrix(rnorm(I * n, mean=1,sd=1), nrow = n) #ncol = I, nrow = n
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/zettel 5 (1)/Zettel5.R')
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/zettel 5 (1)/Zettel5.R')
# Solution to generate the data
N<-c(10,100,1000,5000)
I<-50000
n<-N[1]
n
data <- matrix(rnorm(I * n, mean=1,sd=1), nrow = n) #ncol = I, nrow = n
View(data)
rm(list = ls())
# Solution to generate the data
N<-c(10,100,1000,5000)
I<-50000
n<-N[1]
n
data <- matrix(rnorm(I * n, mean=1,sd=1), nrow = n) #ncol = I, nrow = n
View(data)
# Solution to generate the data
N<-c(10,100,1000,5000)
I<-50 #TODO hoeher
n<-N[1]
n
data <- matrix(rnorm(I * n, mean=1,sd=1), nrow = n) #ncol = I, nrow = n
View(data)
data[i,1:n]
i<-50
data[i,1:n]
data[1:n,i]
dat <- data[1:n,i]
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/zettel 5 (1)/Zettel5.R')
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/zettel 5 (1)/Zettel5.R')
View(data)
?pchisq
#estimator[estimator[,3] > chi,]
mean(c(TRUE,FALSE))
#estimator[estimator[,3] > chi,]
mean(c(TRUE,FALSE,TRUE))
?where
chi <- qchisq(0.95, df=1, lower.tail=TRUE)
x <- estimator[,] > chi
x <- estimator > chi
x <- mean(estimator > chi)
p <- mean(estimator[n,] > chi)
estimator[n,]
estimator[n,]
p <- mean(estimator[n] > chi)
data <- matrix(runif(1600*10000, 0, 1), nrow = 10000)
estimator <- sapply(1:10000,
function(i) sapply(1:40,
function(n) (max(data[i, 1:(40*n)]) -1)*sqrt(40*n)))
View(estimator)
# Solution to generate the data
N<-c(10,100,1000,5000)
I<-50 #TODO hoeher
n<-N[4]
data <- matrix(rnorm(I * n, mean=1,sd=1), nrow = n) #ncol = I, nrow = n
estimator <- sapply(1:I,
function(i) sapply(N,
function(n){
dat <- data[1:n,i]
res <- (2*n/3)*(mean(dat)/sqrt(((n-1)/n)*var(dat))-1)^2
return(res)
}
))
chi <- qchisq(0.95, df=1, lower.tail=TRUE)
p <- mean(estimator[] > chi)
#p <- mean(estimator[] > chi)
y <- sapply(tf, mean)
# Solution for the plot
chi <- qchisq(0.95, df=1, lower.tail=TRUE)
tf <- estimator[] > chi
#p <- mean(estimator[] > chi)
y <- sapply(tf, mean)
#p <- mean(estimator[] > chi)
y <- apply(tf, mean)
#p <- mean(estimator[] > chi)
y <- apply(tf,1, mean)
plot(N, y, type = "l", xlab = "sample size n ",
lwd = 2, col = "steelblue2", main ="MCS of the asymptotic niveau")
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/zettel 5 (1)/Zettel5.R')
I<- 50
J <-200
data <-array(0,dim=c(I,J,2), dimnames = c("col","row","YandDelta"))
data <-array(0,dim=c(I,J,2), list = c("col","row","YandDelta"))
data <-array(0,dim=c(I,J,2), dimnames = list("col","row","YandDelta"))
data <-array(0,dim=c(I,J,2))
for(i in 1:I){
for(j in 1:J){
x<- rnorm(1)
data[i,j,1]<-x
C<-rexp(1)
if(x<=c){
data[i,j,2]<-1
}
}
}
x<- rnorm(1)
typeof(x)
C<-rexp(1)
typeof(C)
is.atomic(C)
if(x=<c){
data[i,j,2]<-1
}
x<- exp(1) #we choose exp for liver failure
is.atomic(C)
C<-rexp(1)
if(x<=c){
data[i,j,2]<-1
}
rm(list = ls())
x<- exp(1) #we choose exp for liver failure
is.atomic(C)
x<- exp(1) #we choose exp for liver failure
is.atomic(x)
x<- rexp(1) #we choose exp for liver failure
is.atomic(x)
data[i,j,1]<-x
C<-rexp(1)
if(x<=c){
data[i,j,2]<-1
}
c<-rexp(1)
if(x<=c){
data[i,j,2]<-1
}
I<- 50
J <-200
data <-array(0,dim=c(I,J,2))
for(i in 1:I){
for(j in 1:J){
x<- rexp(1) #we choose exp for liver failure
is.atomic(x)
data[i,j,1]<-x
c<-rexp(1)
if(x<=c){
data[i,j,2]<-1
}
}
}
print(data)
data[1,1,]
data[2,1,]
data[1,,]
estimator <- getDensityEstim(observations= data[1,,])
#exercise 1
getDensityEstim <-function(observations, K = gauKer, b){
n <- nrow(observations)
if(missing(b)){
b <- n^(-1/3)
}
Y<- observations[1,]
delta <- observations[2,]
yDelta <- delta*exp(Y)/b
destim <- function(x){
kVector <- sapply(Y, function (y){
return(K((x-y)/b))
})
return(mean(kVector))
}
return(destim)
}
data[1,,]
estimator <- getDensityEstim(observations= data[1,,])
estimator(0)
#since the Gaussian kernel has the smallest L2 norm, we chose it (compare to theoretical bound)
gauKer <- function(u){
return ((2*pi)^(-1/2)*exp(-u^2/2))
}
#exercise 1
getDensityEstim <-function(observations, K = gauKer, b){
n <- nrow(observations)
if(missing(b)){
b <- n^(-1/3)
}
Y<- observations[1,]
delta <- observations[2,]
yDelta <- delta*exp(Y)/b
destim <- function(x){
kVector <- sapply(Y, function (y){
return(K((x-y)/b))
})
return(mean(kVector))
}
return(destim)
}
estimator <- getDensityEstim(observations= data[1,,])
estimator(0)
estimator(5)
upperBound <-50
xCoor <- seq(from =0, to =upperBound, length.out =100)
#plot(xCoor,dexp(xCoor), type = 'l',xlab = "x",ylab="density", ylim=c(0,3))
plot(xCoor,dexp(xCoor))
plot(xCoor,dexp(xCoor), type = 'l',xlab = "x",ylab="density", ylim=c(0,3))
plot(xCoor,dexp(xCoor), type = 'l',xlab = "x",ylab="density", ylim=c(0,1))
mycol <- t_col("steelblue", perc = 85, name = "lt.steelblue")
I<- 50
J <-200
data <-array(0,dim=c(I,J,2))
for(i in 1:I){
for(j in 1:J){
x<- rexp(1) #we choose exp for liver failure
is.atomic(x)
data[i,j,1]<-x
c<-rexp(1)
if(x<=c){
data[i,j,2]<-1
}
}
}
#since the Gaussian kernel has the smallest L2 norm, we chose it (compare to theoretical bound)
gauKer <- function(u){
return ((2*pi)^(-1/2)*exp(-u^2/2))
}
#exercise 1
#calculate
getDensityEstim <-function(observations, K = gauKer, b){
n <- nrow(observations)
if(missing(b)){
b <- n^(-1/3)
}
Y<- observations[1,]
delta <- observations[2,]
yDelta <- delta*exp(Y)/b
destim <- function(x){
kVector <- sapply(Y, function (y){
return(K((x-y)/b))
})
return(mean(kVector))
}
return(destim)
}
#plot
t_col <- function(color, percent = 50, name = NULL) {
#      color = color name
#    percent = % transparency
#       name = an optional name for the color
## Get RGB values for named color
rgb.val <- col2rgb(color)
## Make new color using input color as base and alpha set by transparency
t.col <- rgb(rgb.val[1], rgb.val[2], rgb.val[3],
max = 255,
alpha = (100 - percent) * 255 / 100,
names = name)
## Save the color
invisible(t.col)
}
mycol <- t_col("steelblue", perc = 85, name = "lt.steelblue")
# for(i in 1:ncol(data)){
#    X<- data[,i]
destim <-getDensityEstim(observations= data[1,,])
lines(xCoor, destim(xCoor), col=mycol, lwd=2)
xCoor
destim(xCoor)
y <- sapply(xCoor, destim)
y
lines(xCoor, y, col=mycol, lwd=2)
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/Zettel 9/Zettel9.R')
source('C:/Users/Daniel/Google Drive/currentDocumants/Studium/Bachelor/6.Semester/Statistik 2/Zettel/Zettel 9/Zettel9.R')
upperBound <-50
xCoor <- seq(from = 0, to =upperBound, length.out =100)
plot(xCoor, sin(xCoor))
upperBound <-50
xCoor <- seq(from = 0, to =upperBound, length.out =100)
plot(xCoor, xCoor)
upperBound <-50
xCoor <- seq(from = 0, to =upperBound, length.out =100)
plot(xCoor, xCoor)
xCoor
plot(0, 0)
library(plotly)
x <- 1:5/10
install.packages("plotly")
#install.packages("plotly")
library(plotly)
#install.packages("plotly")
library(plotly)
x <- 1:5/10
y <- 1:5
z <- x %o% y
z <- z + .2*z*runif(25) - .1*z
plot_ly(x=x,y=y,z=z, type="surface")
# a) Generating the data -------------------------------------------------
n<- 200
mean1 <- c(1,3)
sigma1 <- 0.6*diag(2)
mean2 <- c(4,2)
sigma2 <- 0.4*diag(2)
data <- 0.8*rmvnorm(n, mean1, sigma1)+0.2*rmvnorm(n, mean2, sigma2)
data <- 0.8*rmvnorm(n, mean1, sigma1)+0.2*rmvnorm(n, mean2, sigma2)
data <- 0.8*rmvnorm(n, mean= mean1, sigma= sigma1)+0.2*rmvnorm(n,mean= mean2,sigma= sigma2)
library(MASS)
data <- 0.8*rmvnorm(n, mean= mean1, sigma= sigma1)+0.2*rmvnorm(n,mean= mean2,sigma= sigma2)
data <- 0.8*mvrnorm(n, mean= mean1, sigma= sigma1)+0.2*mvrnorm(n,mean= mean2,sigma= sigma2)
data <- 0.8*mvrnorm(n, mu= mean1, Sigma= sigma1)+0.2*mvrnorm(n,mu= mean2,Sigma= sigma2)
View(data)
# b) Calculation and plotting --------------------------------------------
kernel <- function(u){
if(abs(u[1])<=1 &abs(u[2])<=1){
return(1/4)
}else{
return (0)
}
}
getDensityEstim <-function(observations, K = kernel, b =0.7){
#observations<-data[1,,]
d <- ncol(observations)
n <- nrow(observations)
BInv <- diag(n)/b
det <- b^d
destim <- function(x0){
M <- sapply(observations, function(x){
return(K(BInv*(x-x0)))
})
result  <-rowSums(M)/(n*det) # Zeilensumme
return(result)
}
return(destim)
}
#install.packages("plotly")
library(plotly)
install.packages("plotly")
library(plotly)
x <- 1:5/10
y <- 1:5
z <- x %o% y
z <- z + .2*z*runif(25) - .1*z
plot_ly(x=x,y=y,z=z, type="surface")
library(plotly)
install.packages("plotly")
#install.packages("plotly")
library(plotly)
x <- 1:5/10
y <- 1:5
z <- x %o% y
z <- z + .2*z*runif(25) - .1*z
plot_ly(x=x,y=y,z=z, type="surface")
#install.packages("plotly")
library(plotly)
x <- 1:5/10
y <- 1:5
z <- x %o% y
z <- z + .2*z*runif(25) - .1*z
plot_ly(x=x,y=y,z=z, type="surface")
source('C:/Users/Daniel/Desktop/paper2020/code/00_parent.R')
runscript(script=mrbrtRR.script, args = args)
source('C:/Users/Daniel/Desktop/paper2020/code/00_parent.R')
source('C:/Users/Daniel/Desktop/paper2020/code/00_parent.R')
source('C:/Users/Daniel/Desktop/paper2020/code/00_parent.R')
